{
  "openapi": "3.1.0",
  "info": {
    "title": "Player Prop API",
    "version": "0.1.0"
  },
  "paths": {
    "/api/v1/players": {
      "get": {
        "tags": [
          "v1"
        ],
        "summary": "List Players",
        "description": "List players in alphabetical order with optional search and pagination.\n\nFiltering behavior:\n  - If `search` is provided, the query performs a case-insensitive match (ILIKE)\n    against:\n      - full name (first_name + last_name)\n      - first_name\n      - last_name\n      - team\n      - position\n      - external_id\n\nPagination behavior:\n  - `limit` caps returned rows.\n  - `offset` skips rows for paging.\n\nArgs:\n    db: SQLAlchemy session (injected).\n    search: Optional case-insensitive filter across identifying fields.\n    include_total: If true, include the total number of matching rows in the response.\n    limit: Maximum number of players to return.\n    offset: Row offset for pagination.\n\nReturns:\n    dict: `{ \"ok\": true, \"players\": [...], \"total\": <int> }`\n    - `total` is only included when `include_total=true`.",
        "operationId": "list_players_api_v1_players_get",
        "parameters": [
          {
            "name": "search",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Case-insensitive search across name, team, position, and external_id.",
              "title": "Search"
            },
            "description": "Case-insensitive search across name, team, position, and external_id."
          },
          {
            "name": "include_total",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "If true, also return `total` rows matching the filter (ignores pagination).",
              "default": false,
              "title": "Include Total"
            },
            "description": "If true, also return `total` rows matching the filter (ignores pagination)."
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 500,
              "minimum": 1,
              "default": 50,
              "title": "Limit"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0,
              "title": "Offset"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/players/{player_id}": {
      "get": {
        "tags": [
          "v1"
        ],
        "summary": "Get Player",
        "description": "Fetch a single player record.\n\nArgs:\n    player_id: Internal numeric player id (`players.id`).\n    db: SQLAlchemy session (injected).\n\nReturns:\n    dict: `{ \"ok\": true, \"player\": {...} }`.\n\nRaises:\n    HTTPException: 404 if the player does not exist.",
        "operationId": "get_player_api_v1_players__player_id__get",
        "parameters": [
          {
            "name": "player_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Player Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/players/{player_id}/projection_ml": {
      "get": {
        "tags": [
          "v1"
        ],
        "summary": "Projection Ml",
        "description": "Generate a model-based projection for the given player and market.\n\nWorkflow:\n    1) Validate the player exists.\n    2) Resolve `market_code` -> `market_id`.\n    3) Fetch the active model for the market from `active_models`.\n    4) Validate the requested `lookback` matches the active model.\n    5) Load the model pipeline from `artifact_path` (joblib).\n    6) Fetch the latest engineered features for the player/market/lookback.\n    7) Run inference and upsert the result into `ml_projections`.\n\nThe prediction is tied to the latest available `as_of_game_date` in\n`player_market_features` for this player/market/lookback.\n\nArgs:\n    player_id: Internal numeric player id (`players.id`).\n    market_code: Market code, e.g. \"rec_yds\" or \"pass_yds\".\n    lookback: Number of prior games used in the feature window; must match the active model.\n    db: SQLAlchemy session (injected).\n\nReturns:\n    dict: Projection payload including `prediction`, `features`, and the resolved `model_name`.\n\nRaises:\n    HTTPException: 404 if player/market/model/features are missing; 400 for lookback mismatch;\n        500 if the model artifact file does not exist on disk.",
        "operationId": "projection_ml_api_v1_players__player_id__projection_ml_get",
        "parameters": [
          {
            "name": "player_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Player Id"
            }
          },
          {
            "name": "market_code",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Market Code"
            }
          },
          {
            "name": "lookback",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 50,
              "minimum": 1,
              "default": 5,
              "title": "Lookback"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/players/{player_id}/ml_projections": {
      "get": {
        "tags": [
          "v1"
        ],
        "summary": "Ml Projection History",
        "description": "Retrieve recent saved ML projections for a player.\n\nThis endpoint returns rows previously written by `projection_ml`. It is\ndesigned for UI history panels and debugging model output over time.\n\nArgs:\n    player_id: Internal numeric player id (`players.id`).\n    market_code: Market code (e.g., \"rec_yds\").\n    model_name: Model name used when the projection was produced (e.g., \"ridge_v1\").\n    lookback: Lookback window used by the model/features.\n    limit: Maximum number of rows to return, ordered by `as_of_game_date` descending.\n    db: SQLAlchemy session (injected).\n\nReturns:\n    dict: `{ \"ok\": true, \"rows\": [...] }` where each row includes the prediction, features JSON, and timestamp.",
        "operationId": "ml_projection_history_api_v1_players__player_id__ml_projections_get",
        "parameters": [
          {
            "name": "player_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Player Id"
            }
          },
          {
            "name": "market_code",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Market Code"
            }
          },
          {
            "name": "model_name",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "default": "ridge_v1",
              "title": "Model Name"
            }
          },
          {
            "name": "lookback",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 50,
              "minimum": 1,
              "default": 5,
              "title": "Lookback"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 200,
              "minimum": 1,
              "default": 20,
              "title": "Limit"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/players/{player_id}/projection_baseline": {
      "get": {
        "tags": [
          "v1"
        ],
        "summary": "Projection Baseline",
        "description": "Fetch the latest precomputed baseline projection for a player/market.\n\nBaseline projections are stored in the `projections` table (typically produced\nby a separate batch job) and represent a lightweight, non-ML projection\napproach (e.g., normal distribution fit based on historical features).\n\nThis endpoint does not run model inference; it retrieves the most recent\nstored projection row.\n\nArgs:\n    player_id: Internal numeric player id (`players.id`).\n    market_code: Market code (e.g., \"rec_yds\").\n    model_name: Identifier for the baseline variant as stored in `projections.model_name`.\n    db: SQLAlchemy session (injected).\n\nReturns:\n    dict: Projection payload with `mean`, `stddev`, and `p_over` for the latest stored game date.\n\nRaises:\n    HTTPException: 404 if player or market is unknown, or if no baseline projection exists.",
        "operationId": "projection_baseline_api_v1_players__player_id__projection_baseline_get",
        "parameters": [
          {
            "name": "player_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Player Id"
            }
          },
          {
            "name": "market_code",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Market Code"
            }
          },
          {
            "name": "model_name",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "default": "baseline_lb5",
              "title": "Model Name"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/jobs/build_features": {
      "post": {
        "tags": [
          "v1"
        ],
        "summary": "Build Features",
        "description": "Compute and upsert engineered features for a given market and lookback window.\n\nThis endpoint materializes the rolling-window features used by both baseline\nand ML projection endpoints.\n\nImplementation details:\n    - Resolves `market_code` -> (market_id, stat_field) from `prop_markets`.\n    - Pulls per-game player stats from `player_game_stats_app`.\n    - For each (player, as_of_game_date) where at least `lookback` prior games exist,\n      computes features over the previous N games:\n        * mean\n        * population stddev\n        * linearly weighted mean favoring recent games\n        * linear trend slope\n    - Upserts into `player_market_features` using a deterministic natural key\n      (player_id, market_id, as_of_game_date, opponent, lookback).\n\nArgs:\n    market_code: Market code (e.g., \"rec_yds\", \"rush_yds\") as stored in `prop_markets.code`.\n    lookback: Number of *prior* games to use for the rolling window.\n    db: SQLAlchemy session (injected).\n\nReturns:\n    dict: Summary payload including market identifiers and number of upserted rows.\n\nRaises:\n    HTTPException: 404 if market is unknown; 400 if the market maps to an unsupported stat field.",
        "operationId": "build_features_api_v1_jobs_build_features_post",
        "parameters": [
          {
            "name": "market_code",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Market Code"
            }
          },
          {
            "name": "lookback",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 50,
              "minimum": 1,
              "default": 5,
              "title": "Lookback"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/jobs/attach_labels": {
      "post": {
        "tags": [
          "v1"
        ],
        "summary": "Attach Labels",
        "description": "Attach the realized stat outcome (`label_actual`) to previously built feature rows.\n\nAfter `build_features` has populated `player_market_features`, this step joins\nthose rows back to the per-game stats table (`player_game_stats_app`) and writes\nthe actual outcome for the marketâs underlying stat field.\n\nThis produces the supervised-learning dataset used by the training job.\n\nArgs:\n    market_code: Market code (e.g., \"rec_yds\") as stored in `prop_markets.code`.\n    db: SQLAlchemy session (injected).\n\nReturns:\n    dict: Summary including updated row count.\n\nRaises:\n    HTTPException: 404 if market is unknown; 400 if the marketâs stat field is not supported.",
        "operationId": "attach_labels_api_v1_jobs_attach_labels_post",
        "parameters": [
          {
            "name": "market_code",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Market Code"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/health": {
      "get": {
        "summary": "Health",
        "description": "Health check endpoint.\n\nReturns a minimal payload used by local dev tooling, containers, and\norchestrators (Docker Compose / Kubernetes) to determine whether the API\nprocess is up and able to serve requests.\n\nReturns:\n    dict: `{\"status\": \"ok\", \"service\": \"api\"}`.",
        "operationId": "health_health_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "HTTPValidationError": {
        "properties": {
          "detail": {
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "type": "array",
            "title": "Detail"
          }
        },
        "type": "object",
        "title": "HTTPValidationError"
      },
      "ValidationError": {
        "properties": {
          "loc": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "type": "array",
            "title": "Location"
          },
          "msg": {
            "type": "string",
            "title": "Message"
          },
          "type": {
            "type": "string",
            "title": "Error Type"
          }
        },
        "type": "object",
        "required": [
          "loc",
          "msg",
          "type"
        ],
        "title": "ValidationError"
      }
    }
  }
}